#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import rclpy
from rclpy.node import Node
import numpy as np
import cv2
import random
import math
import time
from sensor_msgs.msg import Image
from std_msgs.msg import Float32
from cv_bridge import CvBridge
import os


class LaneDetectionNode(Node):
    def __init__(self):
        super().__init__('lane_detection_node')
        
        # Image dimensions and ROI parameters
        self.width = 640
        self.height = 480
        self.offset = 420
        self.gap = 40
        
        # Initialize CV Bridge
        self.bridge = CvBridge()
        
        # Initialize arrow image for steering visualization (optional)
        self.arrow_pic = None
        self.load_arrow_image()
        
        # Publishers
        self.steer_angle_pub = self.create_publisher(Float32, 'steer_angle', 10)
        self.processed_image_pub = self.create_publisher(Image, 'processed_image', 10)
        
        # Subscribers
        self.image_sub = self.create_subscription(
            Image,
            'deepracer/camera/image_raw',
            self.image_callback,
            10
        )
        
        # Timer for processing (if using webcam instead of topic)
        # self.timer = self.create_timer(0.03, self.timer_callback)
        # self.cap = cv2.VideoCapture(0)
        
        self.get_logger().info('Lane Detection Node initialized')

    def load_arrow_image(self):
        """Load steering arrow image if available"""
        try:
            # Try to load the steering arrow image
            if os.path.exists("steer_arrow.png"):
                self.arrow_pic = cv2.imread("steer_arrow.png", cv2.IMREAD_COLOR)
                self.get_logger().info('Steering arrow image loaded successfully')
            else:
                self.get_logger().warn('steer_arrow.png not found, steering visualization disabled')
        except Exception as e:
            self.get_logger().warn(f'Failed to load steering arrow image: {e}')

    def image_callback(self, msg):
        """Process incoming image messages"""
        try:
            # Convert ROS image to OpenCV format
            cv_image = self.bridge.imgmsg_to_cv2(msg, "bgr8")
            
            # Process the image
            lpos, rpos = self.process_image(cv_image)
            
            # Calculate steering angle
            center = (lpos + rpos) / 2
            angle = 320 - center  # 320 is half of 640 (image center)
            steer_angle = angle * 0.4
            
            # Publish steering angle
            steer_msg = Float32()
            steer_msg.data = float(steer_angle)
            self.steer_angle_pub.publish(steer_msg)
            
            # Draw steering visualization if arrow image is available
            if self.arrow_pic is not None:
                cv_image = self.draw_steer(cv_image, steer_angle)
            
            # Publish processed image
            processed_msg = self.bridge.cv2_to_imgmsg(cv_image, "bgr8")
            self.processed_image_pub.publish(processed_msg)
            
            # Display image (optional - comment out for headless operation)
            cv2.imshow('Lane Detection', cv_image)
            cv2.waitKey(1)
            
        except Exception as e:
            self.get_logger().error(f'Error processing image: {e}')

    def timer_callback(self):
        """Timer callback for webcam input (alternative to image topic)"""
        if hasattr(self, 'cap'):
            ret, image = self.cap.read()
            if ret:
                lpos, rpos = self.process_image(image)
                center = (lpos + rpos) / 2
                angle = 320 - center
                steer_angle = angle * 0.4
                
                # Publish steering angle
                steer_msg = Float32()
                steer_msg.data = float(steer_angle)
                self.steer_angle_pub.publish(steer_msg)
                
                if self.arrow_pic is not None:
                    image = self.draw_steer(image, steer_angle)
                
                cv2.imshow('Lane Detection', image)
                cv2.waitKey(1)

    def draw_lines(self, img, lines):
        """Draw detected lines on image"""
        for line in lines:
            x1, y1, x2, y2 = line[0]
            color = (random.randint(0, 255), random.randint(0, 255), random.randint(0, 255))
            img = cv2.line(img, (x1, y1 + self.offset), (x2, y2 + self.offset), color, 2)
        return img

    def draw_rectangle(self, img, lpos, rpos, offset=0):
        """Draw position indicators on image"""
        center = int((lpos + rpos) / 2)
        
        # Left position indicator (green)
        cv2.rectangle(img, (lpos - 5, 15 + offset), (lpos + 5, 25 + offset), (0, 255, 0), 2)
        # Right position indicator (green)
        cv2.rectangle(img, (rpos - 5, 15 + offset), (rpos + 5, 25 + offset), (0, 255, 0), 2)
        # Center of lanes (green)
        cv2.rectangle(img, (center - 5, 15 + offset), (center + 5, 25 + offset), (0, 255, 0), 2)
        # Image center reference (red)
        cv2.rectangle(img, (315, 15 + offset), (325, 25 + offset), (0, 0, 255), 2)
        return img

    def divide_left_right(self, lines):
        """Separate lines into left and right lane lines"""
        low_slope_threshold = 0
        high_slope_threshold = 10

        slopes = []
        new_lines = []

        for line in lines:
            x1, y1, x2, y2 = line[0]
            if x2 - x1 == 0:
                slope = 0
            else:
                slope = float(y2 - y1) / float(x2 - x1)
            
            if (abs(slope) > low_slope_threshold) and (abs(slope) < high_slope_threshold):
                slopes.append(slope)
                new_lines.append(line[0])

        left_lines = []
        right_lines = []

        for j in range(len(slopes)):
            line = new_lines[j]
            slope = slopes[j]
            x1, y1, x2, y2 = line

            if (slope < 0) and (x2 < self.width/2 - 90):  # Left lines
                left_lines.append([line.tolist()])
            elif (slope > 0) and (x1 > self.width/2 + 90):  # Right lines
                right_lines.append([line.tolist()])

        return left_lines, right_lines

    def get_line_params(self, lines):
        """Calculate average slope and intercept of lines"""
        x_sum = 0.0
        y_sum = 0.0
        m_sum = 0.0

        size = len(lines)
        if size == 0:
            return 0, 0

        for line in lines:
            x1, y1, x2, y2 = line[0]
            x_sum += x1 + x2
            y_sum += y1 + y2
            m_sum += float(y2 - y1) / float(x2 - x1)

        x_avg = x_sum / (size * 2)
        y_avg = y_sum / (size * 2)
        m = m_sum / size
        b = y_avg - m * x_avg

        return m, b

    def get_line_pos(self, img, lines, left=False, right=False):
        """Get lane position from detected lines"""
        m, b = self.get_line_params(lines)

        if m == 0 and b == 0:
            if left:
                pos = 0
            if right:
                pos = self.width
        else:
            y = self.gap / 2
            pos = (y - b) / m

            b += self.offset
            x1 = (self.height - b) / float(m)
            x2 = ((self.height/2) - b) / float(m)

            cv2.line(img, (int(x1), self.height), (int(x2), (self.height//2)), (255, 0, 0), 3)

        return img, int(pos)

    def process_image(self, frame):
        """Main image processing pipeline"""
        # Convert to grayscale
        gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)

        # Apply Gaussian blur
        kernel_size = 5
        blur_gray = cv2.GaussianBlur(gray, (kernel_size, kernel_size), 0)

        # Apply Canny edge detection
        low_threshold = 60
        high_threshold = 70
        edge_img = cv2.Canny(np.uint8(blur_gray), low_threshold, high_threshold)

        # Define ROI and apply Hough transform
        roi = edge_img[self.offset : self.offset + self.gap, 0 : self.width]
        all_lines = cv2.HoughLinesP(roi, 1, math.pi/180, 30, 30, 10)

        if all_lines is None:
            return 0, self.width

        # Separate left and right lines
        left_lines, right_lines = self.divide_left_right(all_lines)

        # Get lane positions
        frame, lpos = self.get_line_pos(frame, left_lines, left=True)
        frame, rpos = self.get_line_pos(frame, right_lines, right=True)

        # Draw detected lines
        frame = self.draw_lines(frame, left_lines)
        frame = self.draw_lines(frame, right_lines)
        
        # Draw center reference line
        cv2.line(frame, (230, 235), (410, 235), (255, 255, 255), 2)

        # Draw position indicators
        frame = self.draw_rectangle(frame, lpos, rpos, offset=self.offset)

        return lpos, rpos

    def draw_steer(self, image, steer_angle):
        """Draw steering wheel visualization"""
        if self.arrow_pic is None:
            return image

        try:
            arrow_pic_copy = self.arrow_pic.copy()
            
            origin_height = arrow_pic_copy.shape[0]
            origin_width = arrow_pic_copy.shape[1]
            steer_wheel_center = origin_height * 0.74
            arrow_height = self.height // 2
            arrow_width = int((arrow_height * 462) / 728)

            # Rotate steering wheel based on angle
            matrix = cv2.getRotationMatrix2D(
                (origin_width/2, steer_wheel_center), 
                steer_angle * 2.5, 
                0.7
            )

            # Apply rotation and resize
            arrow_pic_copy = cv2.warpAffine(
                arrow_pic_copy, 
                matrix, 
                (origin_width + 60, origin_height)
            )
            arrow_pic_copy = cv2.resize(
                arrow_pic_copy, 
                (arrow_width, arrow_height), 
                interpolation=cv2.INTER_AREA
            )

            # Create mask and overlay
            gray_arrow = cv2.cvtColor(arrow_pic_copy, cv2.COLOR_BGR2GRAY)
            _, mask = cv2.threshold(gray_arrow, 1, 255, cv2.THRESH_BINARY_INV)

            # Calculate ROI bounds
            y_start = self.height - arrow_height
            y_end = self.height
            x_start = max(0, (self.width//2) - (arrow_width//2))
            x_end = min(self.width, (self.width//2) + (arrow_width//2))

            # Ensure dimensions match
            roi_height = y_end - y_start
            roi_width = x_end - x_start
            
            if (roi_height > 0 and roi_width > 0 and 
                arrow_height > 0 and arrow_width > 0):
                
                arrow_pic_resized = cv2.resize(arrow_pic_copy, (roi_width, roi_height))
                mask_resized = cv2.resize(mask, (roi_width, roi_height))
                
                arrow_roi = image[y_start:y_end, x_start:x_end]
                arrow_roi = cv2.add(arrow_pic_resized, arrow_roi, mask=mask_resized)
                image[y_start:y_end, x_start:x_end] = arrow_roi

        except Exception as e:
            self.get_logger().warn(f'Error drawing steering visualization: {e}')

        return image

    def destroy_node(self):
        """Clean up resources"""
        if hasattr(self, 'cap'):
            self.cap.release()
        cv2.destroyAllWindows()
        super().destroy_node()


def main(args=None):
    rclpy.init(args=args)
    
    node = LaneDetectionNode()
    
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.shutdown()


if __name__ == '__main__':
    main()
